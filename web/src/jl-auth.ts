/**
 * Jieli RCSP Auth crypto module.
 *
 * Reverse-engineered from libjl_auth.so (ARM64, 14 344 bytes).
 * Tables extracted from offsets 0x1b4c (KS_TABLE), 0x1c4c (SBOX), 0x1d4c (ISBOX).
 * Verified against captured BLE auth exchange.
 */

// ── Tables ──────────────────────────────────────────────────

const KS_TABLE: number[] = [
  0x64,0xac,0x28,0x5a,0xc9,0xb3,0x37,0xc5,0x0a,0x10,0xb7,0xa3,0xba,0xb1,0x97,0x46,
  0x3d,0x05,0xdc,0x66,0x6e,0xf6,0x9a,0xf8,0x0d,0x58,0x95,0x67,0xc6,0xaa,0xab,0xec,
  0xa0,0x68,0x9b,0x96,0xd4,0xeb,0xbf,0x43,0x49,0x36,0xe9,0x6a,0x89,0xd8,0xc3,0x8a,
  0x94,0x63,0x99,0xbc,0x7b,0xbe,0xc1,0x22,0xbb,0x5c,0x71,0xd5,0x1f,0x92,0x57,0x5d,
  0x8f,0x44,0x41,0x1d,0x51,0xe6,0x40,0x17,0xfb,0xfd,0x19,0x32,0x34,0xb8,0x61,0x2a,
  0xca,0x23,0x6f,0xda,0x39,0xf7,0xa2,0x01,0x7f,0xd6,0x31,0xe7,0xde,0x80,0x04,0xdd,
  0x2c,0x59,0x82,0xaf,0xa8,0xe0,0x0f,0xcd,0xa1,0x12,0x3e,0x30,0xd1,0x1c,0xd0,0x3a,
  0x33,0x72,0x2e,0x4f,0x90,0x02,0x13,0x06,0x75,0xce,0x87,0xc2,0xef,0xb2,0xad,0x7d,
  0x38,0x15,0xe1,0x52,0x9f,0x7a,0x6c,0x2f,0x27,0xc4,0xe2,0x81,0xa9,0xcf,0x8d,0xc0,
  0xd7,0xdf,0xff,0x60,0x76,0x14,0x8c,0x5e,0x55,0x09,0xe4,0x08,0xc7,0x42,0x20,0xfc,
  0xd2,0x50,0x91,0xd9,0x4c,0x62,0x9e,0xe8,0xb9,0xa6,0xf9,0x1a,0x00,0x21,0x0b,0xfa,
  0x35,0x9c,0x4e,0x4b,0x69,0x48,0xcb,0x0e,0xc8,0xa4,0x5b,0xea,0x84,0x07,0xb4,0x18,
  0xf4,0xae,0x6b,0xdb,0xa7,0xcc,0x3f,0x8b,0x4a,0x0c,0x3c,0x25,0xe5,0x54,0x4d,0x45,
  0x83,0xed,0x11,0xf0,0xb0,0x53,0x93,0xf2,0x74,0x26,0xb5,0x9d,0x6d,0x7c,0xf3,0x2d,
  0xf1,0x56,0x24,0x7e,0x47,0x1b,0x86,0xbd,0x70,0x8e,0x1e,0x3b,0x73,0x16,0x03,0xb6,
  0xac,0x28,0x5a,0xc9,0xb3,0x37,0xc5,0x0a,0x10,0xb7,0xa3,0xba,0xb1,0x97,0x46,0x88,
]

const SBOX: number[] = [
  0x01,0x2d,0xe2,0x93,0xbe,0x45,0x15,0xae,0x78,0x03,0x87,0xa4,0xb8,0x38,0xcf,0x3f,
  0x08,0x67,0x09,0x94,0xeb,0x26,0xa8,0x6b,0xbd,0x18,0x34,0x1b,0xbb,0xbf,0x72,0xf7,
  0x40,0x35,0x48,0x9c,0x51,0x2f,0x3b,0x55,0xe3,0xc0,0x9f,0xd8,0xd3,0xf3,0x8d,0xb1,
  0xff,0xa7,0x3e,0xdc,0x86,0x77,0xd7,0xa6,0x11,0xfb,0xf4,0xba,0x92,0x91,0x64,0x83,
  0xf1,0x33,0xef,0xda,0x2c,0xb5,0xb2,0x2b,0x88,0xd1,0x99,0xcb,0x8c,0x84,0x1d,0x14,
  0x81,0x97,0x71,0xca,0x5f,0xa3,0x8b,0x57,0x3c,0x82,0xc4,0x52,0x5c,0x1c,0xe8,0xa0,
  0x04,0xb4,0x85,0x4a,0xf6,0x13,0x54,0xb6,0xdf,0x0c,0x1a,0x8e,0xde,0xe0,0x39,0xfc,
  0x20,0x9b,0x24,0x4e,0xa9,0x98,0x9e,0xab,0xf2,0x60,0xd0,0x6c,0xea,0xfa,0xc7,0xd9,
  0x00,0xd4,0x1f,0x6e,0x43,0xbc,0xec,0x53,0x89,0xfe,0x7a,0x5d,0x49,0xc9,0x32,0xc2,
  0xf9,0x9a,0xf8,0x6d,0x16,0xdb,0x59,0x96,0x44,0xe9,0xcd,0xe6,0x46,0x42,0x8f,0x0a,
  0xc1,0xcc,0xb9,0x65,0xb0,0xd2,0xc6,0xac,0x1e,0x41,0x62,0x29,0x2e,0x0e,0x74,0x50,
  0x02,0x5a,0xc3,0x25,0x7b,0x8a,0x2a,0x5b,0xf0,0x06,0x0d,0x47,0x6f,0x70,0x9d,0x7e,
  0x10,0xce,0x12,0x27,0xd5,0x4c,0x4f,0xd6,0x79,0x30,0x68,0x36,0x75,0x7d,0xe4,0xed,
  0x80,0x6a,0x90,0x37,0xa2,0x5e,0x76,0xaa,0xc5,0x7f,0x3d,0xaf,0xa5,0xe5,0x19,0x61,
  0xfd,0x4d,0x7c,0xb7,0x0b,0xee,0xad,0x4b,0x22,0xf5,0xe7,0x73,0x23,0x21,0xc8,0x05,
  0xe1,0x66,0xdd,0xb3,0x58,0x69,0x63,0x56,0x0f,0xa1,0x31,0x95,0x17,0x07,0x3a,0x28,
]

const ISBOX: number[] = [
  0x80,0x00,0xb0,0x09,0x60,0xef,0xb9,0xfd,0x10,0x12,0x9f,0xe4,0x69,0xba,0xad,0xf8,
  0xc0,0x38,0xc2,0x65,0x4f,0x06,0x94,0xfc,0x19,0xde,0x6a,0x1b,0x5d,0x4e,0xa8,0x82,
  0x70,0xed,0xe8,0xec,0x72,0xb3,0x15,0xc3,0xff,0xab,0xb6,0x47,0x44,0x01,0xac,0x25,
  0xc9,0xfa,0x8e,0x41,0x1a,0x21,0xcb,0xd3,0x0d,0x6e,0xfe,0x26,0x58,0xda,0x32,0x0f,
  0x20,0xa9,0x9d,0x84,0x98,0x05,0x9c,0xbb,0x22,0x8c,0x63,0xe7,0xc5,0xe1,0x73,0xc6,
  0xaf,0x24,0x5b,0x87,0x66,0x27,0xf7,0x57,0xf4,0x96,0xb1,0xb7,0x5c,0x8b,0xd5,0x54,
  0x79,0xdf,0xaa,0xf6,0x3e,0xa3,0xf1,0x11,0xca,0xf5,0xd1,0x17,0x7b,0x93,0x83,0xbc,
  0xbd,0x52,0x1e,0xeb,0xae,0xcc,0xd6,0x35,0x08,0xc8,0x8a,0xb4,0xe2,0xcd,0xbf,0xd9,
  0xd0,0x50,0x59,0x3f,0x4d,0x62,0x34,0x0a,0x48,0x88,0xb5,0x56,0x4c,0x2e,0x6b,0x9e,
  0xd2,0x3d,0x3c,0x03,0x13,0xfb,0x97,0x51,0x75,0x4a,0x91,0x71,0x23,0xbe,0x76,0x2a,
  0x5f,0xf9,0xd4,0x55,0x0b,0xdc,0x37,0x31,0x16,0x74,0xd7,0x77,0xa7,0xe6,0x07,0xdb,
  0xa4,0x2f,0x46,0xf3,0x61,0x45,0x67,0xe3,0x0c,0xa2,0x3b,0x1c,0x85,0x18,0x04,0x1d,
  0x29,0xa0,0x8f,0xb2,0x5a,0xd8,0xa6,0x7e,0xee,0x8d,0x53,0x4b,0xa1,0x9a,0xc1,0x0e,
  0x7a,0x49,0xa5,0x2c,0x81,0xc4,0xc7,0x36,0x2b,0x7f,0x43,0x95,0x33,0xf2,0x6c,0x68,
  0x6d,0xf0,0x02,0x28,0xce,0xdd,0x9b,0xea,0x5e,0x99,0x7c,0x14,0x86,0xcf,0xe5,0x42,
  0xb8,0x40,0x78,0x2d,0x3a,0xe9,0x64,0x1f,0x92,0x90,0x7d,0x39,0x6f,0xe0,0x89,0x30,
]

// ── Constants ───────────────────────────────────────────────

export const STATIC_KEY: number[] = [
  0x06,0x77,0x5f,0x87,0x91,0x8d,0xd4,0x23,
  0x00,0x5d,0xf1,0xd8,0xcf,0x0c,0x14,0x2b,
]

export const MAGIC: number[] = [0x11,0x22,0x33,0x33,0x22,0x11]

const MASK = 0x9999

// ── Key schedule (sub_1038) ─────────────────────────────────

function keySchedule(data16: number[]): number[] {
  const out = new Array<number>(272).fill(0)
  for (let i = 0; i < 16; i++) out[i] = data16[i]

  const buf = data16.slice(0, 16)
  let checksum = 0
  for (const b of data16) checksum ^= b
  buf.push(checksum & 0xff)

  for (let rnd = 0; rnd < 16; rnd++) {
    for (let i = 0; i < 17; i++) {
      const b = buf[i]
      buf[i] = ((b << 3) | (b >>> 5)) & 0xff
    }
    let readPos = (rnd + 1) % 17
    for (let j = 0; j < 16; j++) {
      const src = buf[readPos]
      const tblIdx = 0xf + rnd * 16 - j
      out[16 + rnd * 16 + j] = (KS_TABLE[tblIdx] + src) & 0xff
      readPos += 1
      if (readPos > 16) readPos = 0
    }
  }
  return out
}

// ── Fibonacci butterfly mixing (0x121c–0x1364) ──────────────

function fibonacciMix(s: number[]): number[] {
  const r: Record<number, number> = {}
  const M = 0xffffffff
  r[16]=s[0]; r[17]=s[1]; r[3]=s[2]; r[4]=s[3]
  r[5]=s[4]; r[6]=s[5]; r[7]=s[6]; r[19]=s[7]
  r[20]=s[8]; r[21]=s[9]; r[22]=s[10]; r[23]=s[11]
  r[24]=s[12]; r[25]=s[13]; r[26]=s[14]; r[27]=s[15]

  // Stage 1
  r[28]=(r[17]+r[16]*2)&M; r[16]=(r[17]+r[16])&M
  r[17]=(r[4]+r[3]*2)&M;   r[3]=(r[4]+r[3])&M
  r[4]=(r[6]+r[5]*2)&M;    r[5]=(r[6]+r[5])&M
  r[6]=(r[19]+r[7]*2)&M;   r[7]=(r[19]+r[7])&M
  r[19]=(r[21]+r[20]*2)&M; r[20]=(r[21]+r[20])&M
  r[21]=(r[23]+r[22]*2)&M; r[22]=(r[23]+r[22])&M
  r[23]=(r[25]+r[24]*2)&M; r[24]=(r[25]+r[24])&M
  r[25]=(r[27]+r[26]*2)&M; r[26]=(r[27]+r[26])&M

  // Stage 2
  r[27]=(r[22]+r[19]*2)&M; r[19]=(r[22]+r[19])&M
  r[22]=(r[26]+r[23]*2)&M; r[23]=(r[26]+r[23])&M
  r[26]=(r[16]+r[17]*2)&M; r[16]=(r[17]+r[16])&M
  r[17]=(r[5]+r[6]*2)&M;   r[5]=(r[6]+r[5])&M
  r[6]=(r[20]+r[21]*2)&M;  r[20]=(r[21]+r[20])&M
  r[21]=(r[24]+r[25]*2)&M; r[24]=(r[25]+r[24])&M
  r[25]=(r[7]+r[28]*2)&M;  r[7]=(r[7]+r[28])&M
  r[28]=(r[3]+r[4]*2)&M;   r[3]=(r[4]+r[3])&M

  // Stage 3
  r[4]=(r[24]+r[6]*2)&M;   r[6]=(r[24]+r[6])&M
  r[24]=(r[3]+r[25]*2)&M;  r[3]=(r[25]+r[3])&M
  r[25]=(r[19]+r[22]*2)&M; r[19]=(r[22]+r[19])&M
  r[22]=(r[16]+r[17]*2)&M; r[16]=(r[17]+r[16])&M
  r[17]=(r[20]+r[21]*2)&M; r[20]=(r[21]+r[20])&M
  r[21]=(r[7]+r[28]*2)&M;  r[7]=(r[7]+r[28])&M
  r[28]=(r[5]+r[27]*2)&M;  r[5]=(r[27]+r[5])&M
  r[27]=(r[23]+r[26]*2)&M; r[23]=(r[23]+r[26])&M

  // Stage 4
  r[26]=(r[7]+r[17]*2)&M;  r[17]=(r[17]+r[7])&M
  r[7]=(r[23]+r[28]*2)&M;  r[23]=(r[23]+r[28])&M
  r[28]=(r[6]+r[24]*2)&M;  r[6]=(r[6]+r[24])&M
  r[24]=(r[19]+r[22]*2)&M; r[19]=(r[19]+r[22])&M
  r[22]=(r[20]+r[21]*2)&M; r[20]=(r[20]+r[21])&M
  r[21]=(r[5]+r[27]*2)&M;  r[5]=(r[27]+r[5])&M
  r[27]=(r[16]+r[4]*2)&M;  r[16]=(r[4]+r[16])&M
  r[4]=(r[3]+r[25]*2)&M;   r[3]=(r[25]+r[3])&M

  return [
    r[26]&0xff, r[17]&0xff, r[7]&0xff, r[23]&0xff,
    r[28]&0xff, r[6]&0xff, r[24]&0xff, r[19]&0xff,
    r[22]&0xff, r[20]&0xff, r[21]&0xff, r[5]&0xff,
    r[27]&0xff, r[16]&0xff, r[4]&0xff, r[3]&0xff,
  ]
}

// ── Conditional XOR/ADD mixing ──────────────────────────────

function condMix(state: number[], keyBlock: number[], mask: number, phase: number): number[] {
  const result = state.slice()
  for (let i = 0; i < 16; i++) {
    const bitSet = ((1 << i) & mask) !== 0
    if (phase === 3) {
      result[i] = bitSet ? (result[i] ^ keyBlock[i]) : ((keyBlock[i] + result[i]) & 0xff)
    } else {
      result[i] = bitSet ? ((keyBlock[i] + result[i]) & 0xff) : (result[i] ^ keyBlock[i])
    }
  }
  return result
}

// ── S-box substitution ──────────────────────────────────────

function sboxSub(state: number[]): number[] {
  const result = state.slice()
  for (const pos of [0,3,4,7,8,11,12,15]) result[pos] = SBOX[result[pos]]
  for (const pos of [1,2,5,6,9,10,13,14]) result[pos] = ISBOX[result[pos]]
  return result
}

// ── Block cipher (sub_11b8) ─────────────────────────────────

function blockCipher(stateIn: number[], ek: number[], mode: number): number[] {
  let s = stateIn.slice()
  const initial = stateIn.slice()

  // x9=0: Phase3 + Sbox + Phase5 (before any Fibonacci)
  s = condMix(s, ek.slice(0, 16), MASK, 3)
  s = sboxSub(s)
  s = condMix(s, ek.slice(16, 32), MASK, 5)

  for (let x9 = 1; x9 <= 8; x9++) {
    s = fibonacciMix(s)
    const ekOff = x9 * 0x20

    if (x9 === 8) {
      // Final mixing
      s = condMix(s, ek.slice(0x100, 0x110), MASK, 3)
      break
    }

    // Phase 2 at x9==2 when mode!=0
    if (mode !== 0 && x9 === 2) {
      for (let i = 0; i < 16; i++) {
        const bitSet = ((1 << i) & MASK) !== 0
        s[i] = bitSet ? (s[i] ^ initial[i]) : ((initial[i] + s[i]) & 0xff)
      }
    }

    s = condMix(s, ek.slice(ekOff, ekOff + 16), MASK, 3)
    s = sboxSub(s)
    s = condMix(s, ek.slice(ekOff + 16, ekOff + 32), MASK, 5)
  }

  return s
}

// ── function_E1test (0xacc) ─────────────────────────────────

export function functionE1test(key6: number[], input16: number[], seed16: number[]): number[] {
  const expandedKey = Array.from({length: 16}, (_, i) => key6[i % 6])
  const output = input16.slice(0, 16)

  const ks1 = keySchedule(seed16.slice(0, 16))
  const cipherOut = blockCipher(output, ks1, 0)

  for (let i = 0; i < 16; i++) {
    cipherOut[i] = (expandedKey[i] + (cipherOut[i] ^ input16[i])) & 0xff
  }

  const obf = [
    (seed16[0]  - 0x17) & 0xff,  (seed16[1]  ^ 0xe5),
    (seed16[2]  - 0x21) & 0xff,  (seed16[3]  ^ 0xc1),
    (seed16[4]  - 0x4d) & 0xff,  (seed16[5]  ^ 0xa7),
    (seed16[6]  - 0x6b) & 0xff,  (seed16[7]  ^ 0x83),
    (seed16[8]  ^ 0xe9),          (seed16[9]  - 0x1b) & 0xff,
    (seed16[10] ^ 0xdf),          (seed16[11] - 0x3f) & 0xff,
    (seed16[12] ^ 0xb3),          (seed16[13] - 0x59) & 0xff,
    (seed16[14] ^ 0x95),          (seed16[15] - 0x7d) & 0xff,
  ]

  const ks2 = keySchedule(obf)
  return blockCipher(cipherOut, ks2, 1)
}

// ── Public API ──────────────────────────────────────────────

/** Build a [0x00, rand*16] auth init packet. */
export function getRandomAuthData(): Uint8Array {
  const result = new Uint8Array(17)
  result[0] = 0x00
  crypto.getRandomValues(result.subarray(1))
  return result
}

/** Encrypt a device challenge [0x00, challenge*16] → [0x01, encrypted*16]. */
export function getEncryptedAuthData(deviceData17: Uint8Array): Uint8Array {
  const input16 = Array.from(deviceData17.subarray(1, 17))
  const encrypted = functionE1test(MAGIC, input16, STATIC_KEY)
  const result = new Uint8Array(17)
  result[0] = 0x01
  for (let i = 0; i < 16; i++) result[i + 1] = encrypted[i]
  return result
}
